// Generated by CoffeeScript 1.4.0

/*
 *
 *  Hi there, have a look at my source files here:
 *  https://github.com/stefanRitter/
 *
*/


(function() {

  window.hair = function(canvas) {
    "use strict";

    var LineElement, allLines, animLength, context, demo, doResize, draw, framerate, handleClick, handleKey, header, interval, lineDensity, linelength;
    context = canvas.getContext('2d');
    allLines = [];
    framerate = 24;
    lineDensity = 14;
    linelength = 40;
    interval = null;
    animLength = framerate * 3;
    LineElement = (function() {

      function LineElement(x, y, noise, color) {
        this.x = x;
        this.y = y;
        this.color = color != null ? color : '#000000';
        this.rotate = noise * 360 * Math.PI / 180;
        this.difference = 0;
        this.count = animLength + 1;
        this.colorfactor = 0;
      }

      LineElement.prototype.draw = function() {
        context.save();
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.translate(this.x, this.y);
        if (this.count < animLength) {
          this.rotate += this.difference;
          this.count++;
          this.color = "rgb(" + (this.colorfactor - this.count * 2) + ", 0, 0)";
          if (this.count >= Math.floor((Math.random() * animLength) + 2 * animLength / 3)) {
            handleClick({
              clientX: Math.floor(Math.random() * canvas.width),
              clientY: Math.floor(Math.random() * canvas.height)
            });
          }
        }
        context.rotate(this.rotate);
        context.strokeStyle = this.color;
        context.lineWidth = 1;
        context.beginPath();
        context.moveTo(0, 0);
        context.lineTo(linelength, 0);
        context.stroke();
        context.closePath();
        return context.restore();
      };

      return LineElement;

    })();
    draw = function(x, y, dx, dy) {
      var line, _i, _len, _ref, _ref1;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (dx == null) {
        dx = canvas.width;
      }
      if (dy == null) {
        dy = canvas.height;
      }
      context.clearRect(x, y, dx, dy);
      for (_i = 0, _len = allLines.length; _i < _len; _i++) {
        line = allLines[_i];
        if ((x <= (_ref = line.x) && _ref <= (x + dx)) && (y <= (_ref1 = line.y) && _ref1 <= (y + dy))) {
          line.draw();
        }
      }
      if (allLines[0].count >= animLength) {
        if (interval !== null) {
          clearInterval(interval);
        }
        return interval = null;
      }
    };
    handleClick = function(event) {
      var clientX, clientY, closedist, difference, factor, line, range, rotX, rotY, _i, _len;
      range = canvas.width / 8;
      clientY = event.clientY;
      clientX = event.clientX;
      for (_i = 0, _len = allLines.length; _i < _len; _i++) {
        line = allLines[_i];
        rotX = line.x - clientX;
        rotY = line.y - clientY;
        factor = Math.atan2(rotX, rotY) * 360 * Math.PI / 180;
        difference = factor - line.rotate;
        line.difference = difference / animLength;
        line.count = 0;
        closedist = rotX * rotX + rotY * rotY;
        line.colorfactor = parseInt(255 - (closedist / 600));
      }
      if (interval !== null) {
        clearInterval(interval);
      }
      return interval = setInterval(function() {
        return draw();
      }, 1000 / framerate);
    };
    doResize = function() {
      var x, xnoise, xstart, y, ynoise, _i, _j, _ref, _ref1;
      if (interval !== null) {
        clearInterval(interval);
      }
      interval = null;
      canvas.width = document.body.clientWidth;
      canvas.height = document.body.clientHeight;
      allLines = [];
      xstart = Math.floor(Math.random() * 11);
      xnoise = xstart;
      ynoise = Math.floor(Math.random() * 11);
      for (y = _i = 0, _ref = canvas.height; 0 <= _ref ? _i <= _ref : _i >= _ref; y = _i += lineDensity) {
        ynoise += 0.1;
        xnoise = xstart;
        for (x = _j = 0, _ref1 = canvas.width; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = _j += lineDensity) {
          xnoise += 0.1;
          allLines.push(new LineElement(x, y, Math.random()));
        }
      }
      return draw();
    };
    handleKey = function(event) {
      if (event.keyCode === 27) {
        if (interval !== null) {
          clearInterval(interval);
        }
        return interval = null;
      }
    };
    demo = function() {
      var randX, randY;
      randX = Math.floor(Math.random() * (canvas.width - canvas.width / 4 + 1)) + canvas.width / 8;
      randY = Math.floor(Math.random() * (canvas.height - canvas.height / 4 + 1)) + canvas.height / 8;
      context.fillStyle = '#CC0E5A';
      context.font = 'italic 3em EB Garamond serif';
      context.fillText("click!", randX, randY);
      return setTimeout(function() {
        return handleClick({
          clientX: randX,
          clientY: randY
        });
      }, 800);
    };
    window.addEventListener('resize', doResize, false);
    window.addEventListener('keyup', handleKey, false);
    canvas.addEventListener('click', handleClick, false);
    doResize();
    header = document.getElementsByTagName('header');
    header[0].style.background = 'transparent';
    return setTimeout(function() {
      return demo();
    }, 1900);
  };

}).call(this);
